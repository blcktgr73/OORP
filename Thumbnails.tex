% $Author: oscar $
% $Date: 2009-09-15 16:53:48 +0200 (Tue, 15 Sep 2009) $
% $Revision: 29111 $
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.815in,.815in},
		vmargin={.98in,.98in},
		ignoreheadfoot
	]{geometry}
	\usepackage[hangul]{kotex}
	\input{common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
	\begin{document}
	\appendix
	\renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{섬네일 패턴}
\chalabel{ThumbnailPatterns}

\on{Put these in the right places:}

\label{pat:Adapter}
\label{pat:Facade}

리엔지니어링과 특별히 관련되지는 않지만 리엔지니어링 프로세스와 관련이 있는 패턴도 많이 있다. 이 장에서는 이 책의 어느 지점에서 구체적으로 언급된 패턴만 나열했다. 다음 세 가지 범주로 분류했다.

\index{델라노, 데이비드}
\index{라이징, 린다}
\index{바인더, 로버트}
\begin{bulletlist}
\item \emph{테스팅 패턴(Testing patterns).}
이러한 패턴은 테스트 작업에 집중하는 데 도움이 된다. 물론 이 주제에 대한 방대한 문헌이 있지만, 주요 출처는 델라노와 라이징 \cite{DeLa98a}의 패턴 언어이다. 예를 들어 바인더는 책 한 권 전체를 이 주제에 할애하고 있다 \cite{Bind99a}.

\index{파울러, 마틴}
\index{로버츠, 도널드}
\item \emph{리팩터링 패턴(Refactoring patterns).}
이 패턴은 리엔지니어링 프로젝트 중에 적용할 수 있거나 포워드 엔지니어링 프로젝트 중에도 적용할 수 있는 개별 리팩토링 단계에 중점을 둔다. 주요 출처는 파울러의 공저 \cite{Fowl99a}와 로버츠의 박사 학위 논문 \cite{Robe99a}이 있다.

\item \emph{디자인 패턴(Design patterns).}
리엔지니어링 작업의 결과는 특정 디자인 패턴을 제자리에 배치하는 경우가 매우 많다. 여기서는 리엔지니어링 상황에서 가장 흔히 나타나는 디자인 패턴 몇 가지를 소개한다. 물론 주요 출처는 \emphind{디자인 패턴} 책 \cite{Gamm95a}이다.
\end{bulletlist}

%=================================================================
%:SECTION Testing Patterns
\section{테스팅 패턴}

%:THUMBNAIL -- {Retest Persistent Problems}
\thumbnail{지속적인 문제 재테스트하기}{RetestPersistentProblems}

\paragraph*{문제:}
구현 중인 기능에 관계없이 시스템에서 어떤 영역을 집중적으로 테스트해야 하는가?

\paragraph*{솔루션:}
현재 문제를 해결할 뿐만 아니라 후속 테스트에 사용할 수 있도록 지속적으로 발생하는 문제 영역과 테스트 케이스 목록을 작성하여 이를 검증하자. 새로운 기능이 추가되지 않더라도 이러한 영역을 철저하게 테스트하자. 릴리스가 출시되기 전에 마지막으로 한 번이라도 정기적으로 다시 테스트하자.

\paragraph*{출처:}
Patterns for system testing \cite{DeLa98a}.

\paragraph*{참조처:}
\patpgref{변경할 때마다 회귀 테스트하기}{RegressionTestAfterEveryChange}.

%:THUMBNAIL -- {Test Fuzzy Features}
\thumbnail{퍼지 기능 테스트하기}{TestFuzzyFeatures}

\paragraph*{문제:}
시스템에서 발생할 수 있는 문제 영역을 정확히 찾아내어 최소한의 시간으로 가장 많은 문제를 발견하려면 어떻게 해야 할까?

\paragraph*{솔루션:}
시스템에서 제공되는 문서를 학습하자. 모호하거나 제대로 정의되지 않은 영역을 찾아보자. 이러한 영역을 더 철저하게 다루는 테스트 계획을 작성하고 해당 영역에 집중적으로 테스트하자. 디자이너가 기능에 대해 모든 것을 말할 수 있다면 아마도 작동할 것이다. 테스트 중에 주의가 필요한 것은 그들이 이야기 해줄 수 없는 부분이다.

\paragraph*{출처:}
Patterns for system testing \cite{DeLa98a}.

\paragraph*{참조처:}
\patpgref{기본 테스트를 증가시키기}{GrowYourTestBaseIncrementally}.

%:THUMBNAIL -- {Test Old Bugs}
\thumbnail{오래된 버그 테스트하기}{TestOldBugs}

\paragraph*{문제:}
최소한의 시간에 가장 많은 문제를 발견할 수 있도록 시스템의 어떤 영역을 테스트 대상으로 삼아야 하는가?

\paragraph*{솔루션:}
이전 릴리스의 문제 보고서를 검토하여 테스트 사례를 선택하는 데 도움을 받자. 오래된 문제를 모두 테스트하는 것은 비효율적이므로 시스템의 마지막 유효성 검사 스냅샷 이후에 보고된 문제를 살펴보자. 문제 보고서를 분류하여 추가 테스트에 사용할 수 있는 추세가 확인되는지 확인하자.

\paragraph*{출처:}
Patterns for system testing \cite{DeLa98a}.

\paragraph*{참조처:}
\patpgref{기본 테스트를 증가시키기}{GrowYourTestBaseIncrementally}.

%=================================================================
%:SECTION Refactorings
\section{리펙터링}

%:THUMBNAIL -- {Encapsulate Field}
\thumbnail{필드 캡슐화하기}{EncapsulateField}

\paragraph*{다른 명칭:}
\ind{추상 인스턴스 변수(Abstract Instance Variable)} \cite{Robe99a}.

\intent{퍼블릭 필드가 있으면, 프라이빗으로 설정하고 접근자를 제공하자.}

\paragraph*{출처:}
\emph{Refactoring: Improving the Design of Existing Code} \cite{Fowl99a}.

\paragraph*{참조처:}
\patpgref{탐색 코드 제거하기}{EliminateNavigationCode}.

%:THUMBNAIL -- {Extract Method}
\thumbnail{메서드 추출하기}{ExtractMethod}

\intent{함께 그룹화할 수 있는 코드 조각이 있다. 이 조각을 메서드의 목적을 설명하는 이름을 가지는 메서드로 추출하자.}

\paragraph*{출처:}
\emph{Refactoring: Improving the Design of Existing Code} \cite{Fowl99a}.

\paragraph*{참조처:}
\patpgref{이해하기 위해 리팩터링하기}{RefactorToUnderstand}, \patpgref{도트 플롯으로 코드 시각화하기}{VisualizeCodeAsDotplots}, \patpgref{데이터 가까이 동작 이동하기}{MoveBehaviorCloseToData}

%:THUMBNAIL -- {Move Method}
\thumbnail{메서드 이동하기}{MoveMethod}

\intent{메서드가 정의된 클래스보다 다른 클래스의 더 많은 기능을 사용하거나 사용할 메서드가 있다. 가장 많이 사용하는 클래스에서 새 메서드를 만든다. 기존 메서드를 단순한 델리게이션으로 바꾸거나 완전히 제거하자.}

\paragraph*{출처:}
\emph{Refactoring: Improving the Design of Existing Code} \cite{Fowl99a}.

\paragraph*{참조처:}
\patpgref{이해하기 위해 리팩터링하기}{RefactorToUnderstand}, \patpgref{동작을 데이터 가까이 이동하기}{MoveBehaviorCloseToData}

%:THUMBNAIL -- {Rename Attribute}
\thumbnail{속성 이름 바꾸기}{RenameAttribute}

\intent{인스턴스 변수의 이름을 바꾸고 그에 대한 모든 참조를 업데이트한다.}

\paragraph*{출처:}
\emph{Practical Analysis for Refactoring} \cite{Robe99a}.

\paragraph*{참조처:}
\patpgref{이해하기 위해 리팩터링하기}{RefactorToUnderstand}.

%:THUMBNAIL -- {Rename Method}
\thumbnail{메소드 이름 바꾸기}{RenameMethod}

\intent{메소드의 이름이 그 목적을 드러내지 않는면, 메소드 이름을 변경하자.}

\paragraph*{출처:}
\emph{Refactoring: Improving the Design of Existing Code} \cite{Fowl99a}.

\paragraph*{참조처:}
\patpgref{이해하기 위해 리팩터링하기}{RefactorToUnderstand}

%:THUMBNAIL -- {Replace Conditional with Polymorphism}
\thumbnail{조건문을 다형성으로 치환하기}{ReplaceConditionalWithPolymorphism}

\intent{개체의 타입에 따라 다른 동작을 선택하는 조건문이 있다. 조건의 각 레그를 서브클래스의 재정의 메서드로 옮긴다. 원본의 메서드는 추상화하자.}

\paragraph*{출처:}
\emph{Refactoring: Improving the Design of Existing Code} \cite{Fowl99a}.

\paragraph*{참조처:}
\patpgref{클라이언트 타입 검사 변환하기}{TransformClientTypeChecks}

%=================================================================
\section{디자인 패턴}

%:THUMBNAIL -- {Abstract Factory}
\thumbnail{추상 팩토리}{AbstractFactory}

\intent{구체적인 클래스를 지정하지 않고 관련 또는 종속 개체의 패밀리를 만들기 위한 인터페이스를 프로바이더가 제공한다.}

\paragraph*{출처:}
\emph{Design Patterns} \cite{Gamm95a}.

\paragraph*{참조처:}
\patpgref{컨트랙트 찾기}{LookForTheContracts}, \patpgref{클라이언트 타입 검사 변환하기}{TransformClientTypeChecks}.

%:THUMBNAIL -- {Adapter}
\thumbnail{어댑터}{Adapter}

\intent{클래스의 인터페이스를 클라이언트가 기대하는 다른 인터페이스로 변환한다. \patref{어댑터}{Adapter}를 사용하면 호환되지 않는 인터페이스 때문에 함께 작동하지 않던 클래스가 함께 작동할 수 있다.}

\paragraph*{출처:}
\emph{Design Patterns} \cite{Gamm95a}.

\paragraph*{참조처:}
\patpgref{올바른 인터페이스 제시하기}{PresentTheRightInterface}, \patpgref{동작을 데이터 가까이 이동하기}{MoveBehaviorCloseToData}.

%:THUMBNAIL -- {Facade}
\thumbnail{파사드}{Facade}

\intent{서브시스템의 인터페이스 집합에 통합 인터페이스를 프로바이더로 제공한다. \patref{파사드}{Facade}는 하위 시스템을 더 쉽게 사용할 수 있는 상위 레벨 인터페이스를 정의한다.}

\paragraph*{출처:}
\emph{Design Patterns} \cite{Gamm95a}.

\paragraph*{참조처:}
\patpgref{탐색 코드 제거하기}{EliminateNavigationCode}, \patpgref{신 클래스 분할하기}{SplitUpGodClass}.

%:THUMBNAIL -- {Factory Method}
\thumbnail{팩토리 메서드}{FactoryMethod}

\intent{개체를 생성하기 위한 인터페이스를 정의하되, 인스턴스화할 클래스는 서브클래스가 결정하도록 한다. \patref{팩토리 메서드}{FactoryMethod}는 클래스가 인스턴스화를 서브클래스로 연기할 수 있도록 한다.}

\paragraph*{출처:}
\emph{Design Patterns} \cite{Gamm95a}.

\paragraph*{참조처:}
\patpgref{컨트랙트 찾기}{LookForTheContracts}

%:THUMBNAIL -- {Flyweight}
\thumbnail{경량}{Flyweight}

\intent{공유를 사용하여 많은 수의 세분화된 개체를 효율적으로 지원한다.}

\paragraph*{출처:}
\emph{Design Patterns} \cite{Gamm95a}.

\paragraph*{참조처:}
\patpgref{디자인 추측하기}{SpeculateAboutDesign}

%:THUMBNAIL -- {Null Object}
\thumbnail{널 객체}{NullObject}

\intent{\patref{널 객체}{NullObject}는 동일한 인터페이스를 공유하지만 아무 일도 하지 않는 다른 객체에 대한 대리자(surrogate)를 제공한다. 따라서 \patref{널 객체}{NullObject}는 아무것도 하지 않는 방법에 대한 구현 결정을 캡슐화하고 해당 세부 사항을 공동 작업자에게 숨긴다.}

\paragraph*{출처:}
\emph{Null Object} \cite{Wool98a}.

\paragraph*{참조처:}
\patpgref{널 객체 도입하기}{IntroduceNullObject}.

%:THUMBNAIL -- {Quantity}
\thumbnail{수량}{Quantity}

\paragraph*{문제:}
6피트 또는 \$5와 같은 값을 나타냅니다.

\paragraph*{솔루션:}
금액과 단위를 모두 포함하는 수량 타입을 사용한다. 달러와 같은 통화는 일종의 단위(unit)이다.

\paragraph*{출처:}
\emph{Analysis Patterns: Reusable Objects Models} \cite{Fowl97b}.

\paragraph*{참조처:}
\patpgref{퍼시스턴트 데이터 분석하기}{AnalyzeThePersistentData}.

%:THUMBNAIL -- {Singleton}
\thumbnail{싱글턴}{Singleton}

\intent{클래스에 인스턴스가 하나만 있는지 확인하고 이에 대한 전역 액세스 지점을 제공한다.}

\paragraph*{출처:}
\emph{Design Patterns} \cite{Gamm95a}.

\paragraph*{참조처:}
\patpgref{한 시간 안에 모든 코드 읽기}{ReadAllTheCodeInOneHour}.

%:THUMBNAIL -- {State}
\thumbnail{상태}{State}

\intent{객체의 내부 상태가 변경될 때 객체의 동작을 변경하도록 허용한다. 객체가 클래스를 변경하는 것처럼 보인다.}

\paragraph*{출처:}
\emph{Design Patterns} \cite{Gamm95a}.

\paragraph*{참조처:}
\patpgref{상태 추출하기}{FactorOutState}.

%:THUMBNAIL -- {State Patterns}
\thumblang{상태 패턴}{StatePatterns}

\intent{\patref{State}{State} 패턴 패턴 언어는 \patref{State}{State} 패턴을 구체화(refine and clarify)한다.}

\paragraph*{출처:}
\emph{State Patterns} \cite{Dyso97a}.

\paragraph*{참조처:}
\patpgref{상태 추출하기}{FactorOutState}.

%:THUMBNAIL -- {Strategy}
\thumbnail{전략}{Strategy}

\intent{알고리즘 제품군을 정의하고, 각 알고리즘을 별도의 클래스로 캡슐화하며, 각 클래스를 동일한 인터페이스로 정의하여 상호 교환할 수 있도록 한다. \patref{전략}{Strategy}을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.}

\paragraph*{출처:}
\emph{Design Patterns} \cite{Gamm95a}.

\paragraph*{참조처:}
\patpgref{전략 추출하기}{FactorOutStrategy}.

%:THUMBNAIL -- {Template Method}
\thumbnail{템플리트 메서드}{TemplateMethod}

\intent{오펴레이션에서 알고리즘의 골격을 정의하여 일부 단계를 하위 클래스로 연기한다. \patref{템플릿 메서드}{TemplateMethod}를 사용하면 서브클래스가 알고리즘의 구조를 변경하지 않고 알고리즘의 특정 단계를 재정의할 수 있다.}

\paragraph*{출처:}
\emph{Design Patterns} \cite{Gamm95a}.

\paragraph*{참조처:}
\patpgref{계약 찾기}{LookForTheContracts}.

%:THUMBNAIL -- {Visitor}
\thumbnail{비지터}{Visitor}

\intent{객체 구조의 요소에 대해 수행할 오퍼레이션을 나타낸다. \patref{비지터}{Visitor}를 사용하면 연산이 수행되는 요소의 클래스를 변경하지 않고도 새 오펴레이션을 정의할 수 있다.}

\paragraph*{출처:}
\emph{Design Patterns} \cite{Gamm95a}.

\paragraph*{참조처:}
\patpgref{동작을 데이터 가까이 이동하기}{MoveBehaviorCloseToData}.

%=============================================================
\ifx\wholebook\relax\else
   \bibliographystyle{alpha}
   \bibliography{scg}
   \end{document}
\fi
%=============================================================

